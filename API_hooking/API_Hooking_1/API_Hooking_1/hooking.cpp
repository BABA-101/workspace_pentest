#include <windows.h>

typedef int(__cdecl* CatProc)(LPCTSTR say);

// 원래의 바이트를 저장하기 위한 버퍼
char originalBytes[5];

FARPROC hookedAddress;

int __stdcall myFunc(LPCTSTR say) {
	HINSTANCE petDll;
	CatProc catFunc;

	// 언후크 함수: 원래의 바이트 덮어쓰기
	WriteProcessMemory(GetCurrentProcess(), (LPVOID)hookedAddress, originalBytes, 5, NULL);

	// 원래 함수로 돌아가서 텍스트 수정
	petDll = LoadLibrary("pet.dll");
	catFunc = (CatProc)GetProcAddress(petDll, "Cat");

	return (catFunc)("안녕하세요. 참새입니다. 야짹야옹짹");
}

// 후킹 로직
void setMySuperHook() {
	HINSTANCE hLib;
	VOID* myFuncAddress;
	DWORD* rOffset;
	DWORD src;
	DWORD dst;
	CHAR patch[5] = { 0 };

	// 함수 Cat의 메모리 주소를 얻기
	hLib = LoadLibraryA("pet.dll");
	hookedAddress = GetProcAddress(hLib, "Cat");

	// 처음 5바이트를 원래의 버퍼에 저장
	ReadProcessMemory(GetCurrentProcess(), (LPCVOID)hookedAddress, originalBytes, 5, NULL);

	// myFunc로 점프하여 덮어쓰기
	myFuncAddress = &myFunc;

	// Patch 작성 :: (5바이트 점프) 명령 이후에 점프할 것. 오프셋 = 목적지address - 소스address
	src = (DWORD)hookedAddress + 5;
	dst = (DWORD)myFuncAddress;
	rOffset = (DWORD*)(dst - src);

	// \xE9 - 점프 명령어
	memcpy(patch, "\xE9", 1);
	memcpy(patch + 1, &rOffset, 4);

	// Cat 함수을 Patch. (Cat 기능을 myFunc로 redirection).
	WriteProcessMemory(GetCurrentProcess(), (LPVOID)hookedAddress, patch, 5, NULL);

}

int main() {
	HINSTANCE petDll;
	CatProc catFunc;

	petDll = LoadLibrary("pet.dll");
	catFunc = (CatProc)GetProcAddress(petDll, "Cat");

	// 원래의 Cat 함수 호출
	(catFunc)("야옹야옹1");

	// hook 설치
	setMySuperHook();

	//후크 설치 후 Cat 함수 다시호출.
	(catFunc)("야옹야옹2");

}