#include <stdio.h>
#include <windows.h>


typedef struct _THREAD_PARAM {
	FARPROC pFunc[2];
	char szBuf[4][128];

}THREAD_PARAM, * PTHREAD_PARAM;


//LoadLibrary()
typedef HMODULE(WINAPI* PFLOADLIBRARY)(
	LPCSTR lpLibFileName
	);

//GetProcAddress()
typedef HMODULE(WINAPI* PFGETPROCADDRESS)(
	HMODULE hModule,
	LPCSTR lpProcName
	);

//MessageBox()
typedef HMODULE(WINAPI* PFMESSAGEBOX)(
	HWND hWnd,
	LPCSTR lpText,
	LPCSTR lpCaption,
	UINT uType
	);

// ThreadProc
DWORD WINAPI ThreadProc(LPVOID lParam) {
	PTHREAD_PARAM pParam = (PTHREAD_PARAM)lParam;
	HMODULE hMod = NULL;
	FARPROC pFunc = NULL;

	hMod = ((PFLOADLIBRARY)pParam->pFunc[0])(pParam->szBuf[0]);
	pFunc = (FARPROC)((PFGETPROCADDRESS)pParam->pFunc[1])(hMod, pParam->szBuf[1]);
	((PFMESSAGEBOX)pFunc)(NULL, pParam->szBuf[2], pParam->szBuf[3], MB_OK);

	return 0;
}



void CodeInjection(DWORD dwPID)
{
	HMODULE hMod = NULL;
	THREAD_PARAM param = { 0, };
	HANDLE hProcess = NULL;
	HANDLE hThread = NULL;
	LPVOID pRemoteBuf[2] = { 0, };
	DWORD dwSize = 0;

	hMod = GetModuleHandleA("kernel32.dll");

	//각 함수들의 주소를 THREAD_PARAM 구조체에 저장
	param.pFunc[0] = GetProcAddress(hMod, "LoadLibrary");
	param.pFunc[1] = GetProcAddress(hMod, "GetProcAddress");
	strcpy_s(param.szBuf[0], "user32.dll"); //LoadLibrary 함수에 전달할 인자
	strcpy_s(param.szBuf[1], "MessageBox"); //GetProcAddress 함수에 전달할 인자
	// messageBox에 전달할 인자 2개
	strcpy_s(param.szBuf[2], "Code Injection Success"); 
	strcpy_s(param.szBuf[3], "Code Injection");

	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID);
	printf("Process Handle address -> 0x%x\n", hProcess);
	

	//THREAD_PARAM 구조체를 위한 공간할당 (data할당)
	dwSize = sizeof(THREAD_PARAM);
	pRemoteBuf[0] = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT, PAGE_READWRITE);

	printf("RemoteBuf[0] address -> 0x%x\n", pRemoteBuf[0]);

	WriteProcessMemory(hProcess, pRemoteBuf[0], (LPVOID)&param, dwSize, NULL);


	//ThreadProc 함수를 위한 할당. (code할당)
	dwSize = (DWORD)CodeInjection - (DWORD)ThreadProc;
	pRemoteBuf[1] = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	printf("RemoteBuf[1] address -> 0x%x\n", pRemoteBuf[1]);
	printf("ThreadProc address -> 0x%x\n", (LPVOID)ThreadProc);

	WriteProcessMemory(hProcess, pRemoteBuf[1], (LPVOID)ThreadProc, dwSize, NULL);
	

	//새로운 스레드 우ㅕㄴ격 생성
	hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pRemoteBuf[1], pRemoteBuf[0], 0, NULL);

	WaitForSingleObject(hThread, INFINITE);

	CloseHandle(hThread);
	CloseHandle(hProcess);
}


int main(int argc, const char* argv[]) {
	DWORD dwPID = 0;

	puts("Code Injection...\n");
	dwPID = (DWORD)atol(argv[1]);

	CodeInjection(dwPID);

	return 0;
}